control + c 或 q : 终止当前操作

cd ~ : 退回到Home目录
touch 文件名 : 创建新文件
gedit 文件名 ： 用gedit编辑器打开文件来编辑
chmod 数字 文件名 ： 设置文件的可执行权限
chown 用户名 ： 把文件所有者改成该用户
./文件名 ： 执行文件

ls -al //显示当前目录下的所有文件及文件夹包括隐藏的.和..等的详细信息
pwd : 显示当前所在绝对目录
mkdir -p a/b/c : 创建多级目录
cp 文件名 目录名 ： 复制文件到目录中
cp -r 目录 目录 ： 复制目录到目录中
rm 文件名 ： 删除文件
rm -f 文件名 ： 强制删除只读文件
rm -r 目录名 ： 删除目录
mv 文件 目的目录 ： 移动文件
mv 旧文件吗 新文件名 ： 重命名文件
cat 文件名 ： 打印文件内容
cat -n 文件名 ： 打印并显示行号
nl 文件名 ： 打印带行号的内容
more 文件名 ： 打开文件一屏的内容，Enter向下滚动一行，Space滚动一屏
tail 文件名 ： 只查看最后10行
tail -n 数字 文件名 ： 只看最后n行
file 文件名 ： 查看文件类型

tmp=a : 给tmp变量赋值a
echo $tmp : 显示变量的值 $表示引用！！
export temp : 导出变量tmp为环境变量
unset temp : 删除环境变量
如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好。

文件名.sh ： linux的脚本文件
文件名.c : C语言文件
gcc -o 文件名.c : 生成可执行的文件

echo "PATH=$PATH:/home/wanhongjia/mybin" >> .zshrc : 将自定义路径添加到环境变量中
上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 > 是以覆盖的方式重定向到一个文件中
source .zshrc ： 让环境变量立即生效

sudo apt-get update : 访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑
sudo apt-get upgrade : 把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新
sudo apt-get install 名字 ： 安装某一个功能

locate /etc/sh : 查找etc下所有以sh开头的文件
locate /usr/share/\*.jpg : 查找目录下所有jpg文件 
which 软件名 ： 是否安装了某个软件，只从path指定路径去查找
find path -name 文件名 : 搜索某个名字的文件或目录
find ~ -mtime 0 : 列出当天有改动的文件

zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop : 将目录 /home/shiyanlou/Desktop 打包成一个文件，并查看了打包后文件的大小和类型。第一行命令中，-r 参数表示递归打包包含子目录的全部内容，-q 参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名。
-9 or -1 : 设置压缩级别为 9 和 1（9 最大，1 最小）
-e : 加密压缩包

du : 查看占用空间大小
unzip -q shiyanlou.zip -d ziptest ： 使用安静模式，将文件解压到指定目录

tar -cf shiyanlou.tar /home/shiyanlou/Desktop ： -c 表示创建一个 tar 包文件，-f 用于指定创建的文件名
tar -xf shiyanlou.tar -C tardir ：解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）：

df -h : 查看磁盘容量
dd if=输入文件名 of=输出文件名 bs=每块的大小 count=块数 conv=转换方式 ： 用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换
sudo mkfs.ext4 文件名 : 将我们的虚拟磁盘镜像格式化为ext4文件系统

type 命令名称 ： 返回命令的类型
help 命令 ： 返回内部命令帮助
命令 --help : 返回外部命令帮助
man 指令 ： 得到更详细的帮助
info 指令 ： 最详细的帮助

在LINUX中，周期执行的任务一般由cron这个守护进程来处理

sudo cron -f & : 启动
crontab -e : 为当前用户添加
sudo crontab -e : 为root用户添加
crontab -l : 查看添加的任务
pgrep cron : 确定我们的 cron 是否成功的在后台启动
crontab -r : 删除任务

#输入数据，基本格式为 :
*　　*　　*　　*　　*　　command
第一个* ： 第几分钟
第二个 ： 第几小时
第三个 ： 第几天
第四个 ： 第几月
第五个 ： 星期几

例子：备份日志
每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/shiyanlou/tmp/ 目录
命名格式为 年-月-日，比如今天是2017年4月1日，那么文件名为 2017-04-01

0 3 * * * sudo rm /home/shiyanlou/tmp/*
0 3 * * * sudo cp /var/log/alternatives.log /home/shiyanlou/tmp/$(date +\%Y-\%m-\%d)

一次性输入多个命令，让它自己去依次执行各命令：使用；分隔命令
which a && b : a命令执行结果为0，则执行b命令
which a || b : a命令结果不为0，则执行b命令

管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），
它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。

我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示

ls -al /etc
ls -al /etc | less  //可以一行行地查看内容

cut：以某种方式按照文件的行进行分割

参数列表：
 -b 按字节选取 忽略多字节字符边界，除非也指定了 -n 标志
 -c    按字符选取
 -d 自定义分隔符，默认为制表符。
 -f 与-d一起使用，指定显示哪个区域。

grep 命令选项 查找的表达式 文件 ： 查找匹配字符串
-r 参数表示递归搜索子目录中的文件,
-n表示打印匹配项行号，
-I表示忽略二进制文件

查看环境变量中以"yanlou"结尾的字符串
export | grep ".*yanlou$"
$表示一行的末尾

wc 命令用于统计并输出一个文件中行、单词和字节的数目
# 行数
$ wc -l 地址
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd

默认为字典排序 ： cat /etc/passwd | sort
反转排序：cat /etc/passwd | sort -r

uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序
-c或--count 在每列旁边显示该行重复出现的次数。
-d或--repeated 仅显示重复出现的行列。

echo '文本’ | tr -d '字符集‘ : 删除文本中所有和字符集匹配的字符
echo '文本’ | tr -s '字符集‘ : 去除连续并重复的字符

join [option] file1 file2 : 合并两个文件中包含相同内容的那一行
echo 'hello' > file1
echo 'world' > file2
join file1 file2

paste [option] ... : 直接将多个文件合并到一起

Linux 默认提供了三个特殊设备，用于终端的显示和输出，
分别为stdin（标准输入,对应于你在终端的输入），0表示（文件描述符）
stdout（标准输出，对应于终端的输出），1表示
stderr（标准错误输出，对应于终端的输出）。 2表示

不要将管道和重定向混淆，管道默认是连接前一个命令的输出到下一个命令的输入，
而重定向通常是需要一个文件来建立两个命令的连接

cat Documents/test.c hello.c > 文件 ：输出重定向到一个文件 
tee 选项 文件 ：除了将输出重定向到文件,也将信息打印在终端

exec : 使用指定的命令替换当前的shell
exec 1>文件 ： 将标准输出定向到一个文件，1表示标准输出

/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，
或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF。

将标准错误重定向到标准输出，再将标准输出重定向到文件，
注意要将重定向到文件写到前面
$ cat Documents/test.c hello.c >somefile  2>&1

xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。
它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。

wget 网址 ： 下载单个文件
wget -O 新文件名 网址 ： 下载文件并重新命名

sort -rn -k1 : n按数字排序，r倒序排序，k1根据第一列排序
head -n 文件名 : 显示文件的前n行



正则表达式：
shi* :
在正则表达式中*表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，
比如它可以匹配"sh","shii","shish","shiishi"等等，
而作为通配符表示匹配通配符后面任意多个任意字符，
所以它可以匹配"shiyanlou"，和"shilouyan"两个字符。

+表示前面的字符必须出现至少一次(1次或多次)，例如，"goo+gle",可以匹配"gooogle","goooogle"等；
?表示前面的字符最多出现一次(0次或1次)，例如，"colou?r",可以匹配"color"或者"colour";
*星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“0*42”可以匹配42、042、0042、00042等。

()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。
例如，"gr(a|e)y"等价于"gray|grey"，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），
"(grand)?father"匹配father和grandfather（这里体验了范围，?将圆括号内容作为一个整体匹配）。

{n}	n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。
{n,}	n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”
{n,m}	m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。

^	匹配输入字符串的开始位置。放到括号内表示排除字符
$	匹配输入字符串的结束位置。

x｜y	匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”

grep '' : 它能使用正则表达式搜索文本，并把匹配的行打印出来

[:alnum:]	代表英文大小写字母及数字，亦即 0-9, A-Z, a-z
[:alpha:]	代表任何英文大小写字母，亦即 A-Z, a-z
[:blank:]	代表空白键与 [Tab] 按键两者
[:cntrl:]	代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
[:digit:]	代表数字而已，亦即 0-9
[:graph:]	除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
[:lower:]	代表小写字母，亦即 a-z
[:print:]	代表任何可以被列印出来的字符
[:punct:]	代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...
[:upper:]	代表大写字母，亦即 A-Z
[:space:]	任何会产生空白的字符，包括空白键, [Tab], CR 等等
[:xdigit:]	代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节




sed 参数 命令 文件 ： 过滤和转换文本的流编辑器
-n	安静模式，只打印受影响的行，默认打印输入数据的全部内容
-i	将直接修改输入文件内容，而不是打印到标准输出设备
sed -i 's/sad/happy/g' test  
表示将test文件中的"sad"替换为"happy"，
s	行内替换
c	整行替换
g       表示全局范围
p	打印指定行，通常与-n参数配合使用




AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一
  awk '{
> if(NR==1){
> print $1 "\n" $2 "\n" $3
> } else {
> print}
> }' test
NR表示当前读入的记录数，你可以简单的理解为当前处理的行数
$N其中N为相应的字段号，这也是awk的内建变量，它表示引用相应的字段
$0表示应用当前行的全部内容
或者：
  awk '{
> if(NR==1){
> OFS="\n"
> print $1, $2, $3
> } else {
> print}
> }' test
OFS     表示输出时的字段分隔符，默认为" "空格
FS	字段分隔符，由正则表达式表示，默认为" "空格

例子：
1、在文件 /home/shiyanlou/data2 中匹配数字开头的行，将所有以数字开头的行都写入 /home/shiyanlou/num 文件。
grep '^[0-9]' /home/shiyanlou/data2 > /home/shiyanlou/num

2、在文件 /home/shiyanlou/data2 中匹配出正确格式的邮箱，将所有的邮箱写入 /home/shiyanlou/mail 文件，注意该文件中每行为一个邮箱。
grep -E '^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$' /home/shiyanlou/data2 > /home/shiyanlou/mail
里面的_-表示匹配下划线和横线！！
-E表示拓展的正则表达式

# 更新软件源
$ sudo apt-get update
# 升级没有依赖问题的软件包
$ sudo apt-get upgrade
# 升级并解决依赖关系
$ sudo apt-get dist-upgrade
# 显示软件安装在何处
$ sudo dpkg -L 软件名

搜索有无某个软件：
sudo apt-cache search softname1 softname2 softname3……


线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。

进程（process）：进程是程序在一个数据集合上的一次执行过程
程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：

动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。
并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。
独立性：进程可以独立分配资源，独立接受调度，独立地运行。
异步性：进程以不可预知的速度向前推进。
结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。
并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）
并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行

进程可以从两个角度来分：

以进程的功能与服务的对象来分；
以应用程序的服务类型来分；

第一个角度来看，我们可以分为用户进程与系统进程：

用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。
系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。
第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程

交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。
批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。
守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。

fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等

exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段

子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少

既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。

在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。

正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。

虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。

另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。

init 为所有进程的父进程或者说是祖先进程

每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。

一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。

与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，

Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。

前台（foreground）就是在终端中运行，能与你有交互的

后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程
ps命令用于显示当前进程 (process) 的状态

我们可以通过 & 这个符号，让我们的命令在后台中运行，比如 ls &
我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去
被停止并放置在后台的工作我们可以使用这个命令来查看: jobs

我们可以通过这样的一个命令将后台的工作拿到前台来: fg [%jobnumber]
#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %

之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令:
bg [%jobnumber]

删除一个工作：
kill -signal %jobnumber

#signal从1-64个信号值可以选择，可以这样查看
kill －l

若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作

若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID
